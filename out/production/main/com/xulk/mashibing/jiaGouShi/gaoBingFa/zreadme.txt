1、线程：一个程序中不同的执行路径

2、启动线程的三种方式：
                    继承thread
                    实现runnable
                    通过线程池 Executors.newCachedThread();

3、yield()方法，当前线程让出一下cpu，然后当前线程和其它线程一起公平竞争cpu
   join()方法，t2线程加入到t1线程里面来
   intterupt() 当前线程会抛出异常，捕获当前异常进行对应的业务处理

4、线程的几种状态 ：new ready running waiting blocked terminated

5、synchronized锁静态方法的时候，锁的是当前Class对象，只有当前class内部的加锁的静态方法由于没有获取到锁，不能访问，
   加锁的非静态方法（锁的是当前对象）或没有加锁的静态方法和没有加锁的非静态方法（不需要锁）都可以继续访问（锁升级的概念其实就是synchronized内部做的优化）
   可重入锁 ：同一把锁可重复获取　（必须是可重入锁）
   锁的是对象头上的两位来表示有没有锁或是什么锁
   发生异常会自动释放当前锁
   synchronized(object) object 不能使string常量，Integer Long
   大家都锁同一个string常量的时候容易造成死锁

   synchronized锁原理（优化之后的原理），首先记录线程id，mardword成为偏向锁，如果发生锁争用，升级为自旋锁，
   默认自旋10次，升级为重量锁，向操作系统获取资源　（锁只能升级不能降级）
   执行时间短、线程数量少的情况下，适合用自旋锁，自旋锁所有线程都占用cpu
   执行时间长、线程数量多的情况下，适合用系统锁，其他等待的线程不占用cpu

   偏向锁原理：第一个线程来的时候，其实是没有加锁的，只是记录当前线程id，默认该对象是当前线程独有的
              再来线程的时候，如果还是当前线程，直接使用该对象，不用考虑加锁问题，如果跟当前记录的线程id不一样
              则升级为自旋锁，也就是说，当前对象是偏向该线程的

   当锁某个对象的时候，对象的属性发生改变看，锁继续有效，对象变成一个新的对象的时候，锁会出问题，
   因为锁，实在对象头上做操作，所以在给对象加锁的时候，一般当前对象定义为final类型的，

6、volatile 保证线程可见性（缓存一致性协议）  禁止指令重排序（例子：单例模式双重检查的时候使用该关键字）
   本来是有一个变量在主内存，两个线程各copy一份副本到自己的工作内存，至于副本改变之后什么时候写回到主内存，不知道
   且两个线程之间，变量副本不可见
   （指令重排序：指令较多的时候，cpu可能会对一些指令进行指令重排）
   new 对象的过程 1申请内存、2改值、3将值复制给变量  指令重排序有可能2、3会交换位置

7、CAS   atomicInteger  使用 CAS技术   CompareAndSet  （无锁 相当于一个乐观锁）
   cas(v, expected, newValue)  if v == e; v = new; otherwise try again or fail
   去改变一个变量的值之前，对变量有一个期望值，如果发现变量的值跟期望值不一样，证明有其他线程改变，
   这个时候需要带着新的期望值重新尝试操作，或者直接fail，如果跟期望值一样，直接操作。
   atomicInteger count = 1; 期望值1，去改变的时候发现cout已经变成了2，证明有其他线程已经改变了这个值，
   这个时候期望值改为2，重新去++操作

8、ReentrantLock 是可重入锁，synchronized也是一种可重入锁，
   ReentrantLock底层是cas的实现，synchronized是一种锁升级的概念

9、公平锁的概念：新的线程来的时候会检查队列里面有没有等待的线程，如果有，进去排队等待，
                 但是，公平锁也不是说谁等的时间长就把锁给谁，还是会竞争锁，只是多了一个检查的动作
   非公平锁就是后进来的线程不会去检查队列里面有没有等待的线程，会直接去争抢锁，

10、读写锁ReadWriteLock 共享锁、排它锁；
